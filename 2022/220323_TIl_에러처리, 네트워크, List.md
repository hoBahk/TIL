## 고민한 점
### 1. 언제 사용자에게 에러를 알려주어야 할까
  - 처음에 앱을 실행했을 때 네트워크 통신이 된다면 Firebase와 Realm을 동기화 하도록 하였고, 네트워크 통신이 되지 않는다면 네트워크 연결이 되어있지 않다는 얼럿을 띄운 후 사용할 수 있도록 하였다. ( 후에는 Realm에만 저장)

- 네트워크 통신이 되는지 안되는지 확인하여 네트워크 통신이 된다면 Firebase와 통신하도록 분기처리 하였다.
   - 처음에는 Delegate 패턴으로 구현하였으나 Delegate 패턴을 사용하면 결국에 NetworkManager가 ViewModel이 하는 일중 일부를 알게 되는 것이라는 생각이 들어 모니터링하는 메서드를 이스케이핑 함수로 구현해 ViewModel에서 호출하도록 하였다.

- Firebase에서 발생하는 에러도 처리하도록 하여 에러 발생 시 얼럿을 띄울 수 있도록 하였다.


### 2. 히스토리 관리를 어떻게 해야할까

히스토리를 관리하는 Manager 타입과 모델타입을 만들어 관리하도록 구현했다.
그리고 appendHistory() 메서드를 만들어서 파라미터를 열거형(추가/이동/삭제) 연관값으로 하여 필요한 데이터를 받아서 히스토리에 올릴 스트링을 만들어 히스토리에 추가하도록 했다.

### 3. 에러처리의 기준?

Service가 ViewModel의 처리방식에 대해 알고, 에러를 보내주지 않는 것은 ViewModel이 에러가 필요해진 시점이 올 때 처리할 작업이 많아지고 위험해진다고 생각했다.
그래서 먼저 에러를 처리할지 말지를 결정하고 에러를 처리한다면 ViewModel까지 에러를 보내주는 것이 맞다고 생각하였다.


## Trouble Shooting

### 1. popover할 때 List의 크기에 맞게 동적으로 변화실킬 순 없을까?
#### 문제점
- List를 popover로 하게 되면 List가 제대로 나오지 않았다.

![image](https://user-images.githubusercontent.com/90945013/159208076-b1ec4d42-5024-4d72-9ec5-7df33f90c0a5.png)

#### 원인
- LIst item의 width가 item의 내용에 따라 달라질거라고 생각하고 있었는데, 다시 생각해보니 내용에 따라 달라지는 것이 아니라 List에 지정된 크기대로 지정되는 것이 아닌가라는 생각이 든다. 
- 일반 뷰는 화면 크기에 따라 그에 맞게 리스트 크기가 정해질 수 있지만 popover에 올린 List는 크기가 정해져 있지 않아 이상하게 나온것으로 보인다.

#### 해결방안
- 1안: List의 크기를 직접 지정해준다.
- 2안: `GeometryReader`를 사용해서 구현한다.
- 3안: Stack과 scrollView를 이용하여 구현한다.

3안을 선택했다.    
- Stack을 사용하면 List item의 내용에 따라 popover 뷰의 크기가 동적으로 적용된다.
- 내용의 크기가 스택의 크기를 만들고 스택의 크기가 popover뷰의 크기를 만들기 때문에 따로 크기를 지정해주지 않아도 된다.


### 2. 네트워크 연결 체크 시 오류
#### 문제점
- 기기에 네트워크가 연결되지 않았을 떄 이를 사용자에게 알리기 위해 `NWPathMonitor`를 이용하 네트워크 연결을 모니터링 하도록 하고 있다.   
- 처음에 앱을 시작할 때는 네트워크 연결이 되어있지 않으면 얼럿으로 통해 사용자에게 알린다.(처음 앱을 시작할떄는 정상)  
- 그런데 앱을 사용하던 도중에 네트워크가 갑자기 끊어지는 상황에서는 에러가 발생하지 않고 네트워크가 다시 연결될 때 연결되지 않는다는 얼럿이 띄워진다. (네트워크 상황과 반대로 동작한다.)


```swift 
monitor.pathUpdateHandler = { [weak self] path in
    DispatchQueue.main.async {
        self?.isConnected = path.status == .satisfied
        self?.isNotConnected = !(self?.isConnected ?? true)
        
        if self?.isConnected == true {
            print("연결됨")
        } else {
            print("연결안됨")
        }
    }
}
monitor.start(queue: queue)
```

#### 원인
- 분명 로직도 맞게 구현을 했고 문제가 없다고 생각했다. 
- 그래서 의심이 되는 것은 시뮬레이터 에러였다.

#### 해결방법
- 실제기기에서 직접 실해해 보니 문제없이 구현한대로 동작하는 것을 확인할 수 있었다.
- 시뮬레이터를 무조건 믿지는 말자..