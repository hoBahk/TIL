## 동작 방식

실제 원본이나 복사본이 수정되기 전까지는 복사를 하지 않고 원본 리소스를 공유한다.

원본이나 복사본에서 수정이 일어날 경우, 그 때 복사하는 작업을 한다.

뭔소리냐

복사를 할 때 우선은 실제 복사를 하지 않고 참조하는 형식으로 한다.

그러다가 원본이나 복사한거나 둘중 하나가 수정이 일어나면 그 때 진짜 복사를 한다.

그래서 처음 수정이 일어날 때는 복사도 같이 하기 때문에 약간의 오버헤드가 발생할 수 있다.

**Swift에선 Collection Type을 복사해서 사용할 때 일어남**

Array, Dictionary, Set 등등

예를 들면..

```swift
func address(of: UnsafeRawPointer) {
    let address = String(format: "%p", Int(bitPattern: of))
    print(address)
}

var array1 = [1, 2, 3, 4, 5]
var array2 = array1

address(of: array1) // 0x100734030
address(of: array2) // 0x100734030

array1[1] = 1 // array1 수정

address(of: array1) // 0x1006377e0  -- 주소 바뀜
address(of: array2) // 0x100734030
```

## 꼬리 질문

- Copy on Write는 어떤 타입에서 사용되는가?
    - Collection Type
- Collection Type에는 무엇이 있는가?
    - Array, Dictionary, Set
- Copy on Write는 값타입에서 일어나는가 참조타입에서 일어나는가?
    - 값 타입
- 값 타입과 참조 타입의 차이가 무엇인가?
    - 값타입
        - 변수를 할당하면 스택 영역에 값이 저장된다.
        - 변수를 복사한 후 복사본을 변경하더라도 원본에 영향을 주지 않는다.
        - 힙 영역을 사용하지 않고 레퍼런스 카운팅이 필요하지 않다.
    - 참조타입
        - 스택 영역에는 포인터(레퍼런스)만 할당되고 실제 데이터는 힙 영역에서 할당된다.
        - 변수를 복사하더라도 하나의 값을 가리키고 있기 때문에 복사본과 원본이 모두 같은 값을 갖는다.
        - 변수를 복사하더라도 레퍼런스 카운트만 +1 되고 실제 값이 복사되지는 않는다.
- memory 구조는 어떻게 되는가?
    - Code
        - 기계어 형태로 저장
        - 컴파일 타임에 결정된다.
        - 중간에 코드가 변경되지 않도록 Read-Only 형태로 저장된다.
    - Data
        - 전역변수, static 변수가 저장
        - 프로그램 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리에서 해제된다.
        - 실행 도중 변수 값이 변경될 수 있으니 Read-Write로 저장된다.
    - Heap
        - **ARC에 의해서 Reference Counting이 관리되는 영역**이다. Code, Data, Stack, Heap 중에서 유일하게 런타입에 결정되기 때문에 **데이터 크기가 확실하지 않은 가변적인 데이터 타입들이 Heap 영역에 할당**된다.
        - Swift에서는 Class의 인스턴스, Closure, 가변적인 String, Array 같은 타입이 Heap영역에 저장된다.
            - 장점
                - **메모리 크기에 대한 제한 없음**
                - 본질적인 범위가 전역이기 때문에, **프로그램의 모든 함수에서 액세스** 할 수 있음
            - 단점
                - 힙 경합(두 개 이상의 쓰레드가 동시에 접근하려고 할 때 Lock 걸림)으로 인한 속도 저하
                - 메모리를 직접 관리해야 함(해제해주지 않을 시 메모리 누수가 발생한다.)
                - 할당, 해제 작업으로 인한 속도 저하
                - 힙 손상(이중 해제, 해제 후 사용 등) 작업으로 인한 속도 저하
    - Stack
        - 함수 호출 시 함수의 지역변수, 매개변수, 리턴값 등이 저장
        - 함수가 종료되면 저장된 메모리 해제
        - 컴파일 타임에 결정되기 때문에 무한히 할당 할 수 없다.
        - LIFO (last in, first out)
            - 장점
                - CPU가 스택 메모리를 효율적으로 구성하기 때문에 속도가 매우 빠름
                - 메모리를 직접 해제를 해주지 않아도 됨
            - 단점
                - 메모리 크기에 대한 제한 있음
                - 지역 변수만 액세스 가능
- 힙 vs 스택
    - 데이터의 크기를 모르거나, 스택에 저장하기엔 큰 데이터의 경우엔 힙에 할당하고 그 외엔 스택에 할당하면 됨
    - 스택에 너무 많은 메모리를 할당하게 되면 스택 오버 플로우 발생하여 어플 강제종료
    - 힙 영역은 낮은 메모리 주소부터 할당 받는것, 스택영역은 높은 메모리 주소부터 할당 받는다.
- 오버헤드의 뜻은?
    - 어떤 처리를 하기 위해 들어가는 간접적인 시간
- 구조체와 클래스 차이
    - 공통점
    - class(클래스)
        - 참조 타입
        - ARC로 메모리를 관리
        - 상속 가능
        - 주소값은 스택영역에 저장, 인스턴스는 힙영역에 저장
    - strcut(구조체)
        - 갑 타입
        - 구조체 인스턴스가 담긴 변수를 새로운 변수에 할당할 때마다 새로운 구조체가 할당되며 새로운 주소에 할당된다.
        - 인스턴스를 스택영역에 저장
- 컴파일 타임과 런타임의 차이?
    - 컴파일
        - 사람이 작성한 언어를 기계가 읽을 수 있도록 번역하는 것
        - 컴파일 타임 에러
            - 프로그램이 성공적으로 컴파일 되는 것을 방해하는 신텍스 에러나 파일 참도 오류와 같은 문제를 말하며, 일반적으로 컴파일러는 문제를 일으킨 소스코드 라인을 알려준다.
    - 런타임 에러
        - 이미 실행가능한 프로그램이긴 한데 프로그램이 실행 중에 발생하는 형태의 예상치 못한 오류
        - 0 나누기, nil 참조, 메모리 부족 오류 등이 있다.
- ARC(Automatic Reference Counting
    - 자동으로 참조 횟수를 추적해서 메모리를 관리한다.
    - 힙 영역에서 메모리 관리
    - 이전에는 MRC 였는데 retain, release로 개발자가 직접 관리해줘야 했는데, ARC는 자동으로 retain, release를 해준다.
    - 문제점으로 강한순환참조가 일어날 수 있다.
        - 메모리 누수가 발생한다.
- 순환참조가 뭔데
    - 두 개의 클래스가 서로를 강한참조 하고 있는 형태
    - 강한순환참조가 되면 하나의 객체를 메모리 해제 하여도 나머지 하나가 메모리 해제가 되지 않아 메모리 누수가 발생한다.
    - 그래서 생명주기가 더 짧은 인스턴스를 가리키는 것을 weak(약한 참조)로 선언하면 약한 순환 참조가 되어 메모리 누수를 방지할 수 있다.
    - 수명이 더 짧은 인스턴스를 weak으로 하는 이유는 대상 인스턴스를 참조하고 있는 중에 언제든지 메모리에서 사라질 수 있기 때문이다.