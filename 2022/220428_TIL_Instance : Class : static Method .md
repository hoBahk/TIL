## Instance Method 와 Class Method의 차이

- 정의된 Class, struct, enum 을 `실체화(인스턴스)` 하여 사용하느냐
    - Instance Method만 인스턴스화 하여 사용
- `실체화(인스턴스)` **하지않고 직접적으로 호출** 하느냐
    - class, static
- Class 가 아닌 struct, enum 에서 선언될 수 있느냐 없느냐
    - class는 instance, class, static 가능
    - struct는 instance,  static 가능
    - enum은 instance, static 가능

## class와 static의 차이

- 오버라이딩이 되냐 안되냐의 차이
- class의 경우에는 서브클래스에서 상속을 받아서 overriding이 가능.
- `final class`을 사용해 더이상 overriding이 불가능하게 선언 가능
- static의 경우에는 서브클래스에서 overriding이 불가능하다.

## 꼬리질문

### 인스턴스 / 타입 메서드 내부에서 self를 사용하면 무슨 뜻인가요?

인스턴스 메서드의 self는 자신의 인스턴스의 self이다.

타입 메서드의 self는 자신의 타입의 self이다.

### struct, enum은 왜 class를 사용할 수 없나요?

- struct, enum은 상속할 수 없기 때문에 class 사용 불가능
- 오버라이딩은 상속할 때 사용하는 것이기 때문에?

### 오버라이딩이 무엇인가요?

- 재정의
- 서브 클래스는 슈퍼 클래스에서 상속할 인스턴스 메서드, 타입 메서드, 인스턴스 프로퍼티, 타입 프로퍼티, 서브스크립트를 구현할 수 있는데, 이것을 "오버라이딩(overriding)"이라고 한다.

### 오버로드는 무엇인가요?

- 중복 선언
- 메서드 이름이 같아도 매개변수의 갯수나 이름이 다르면 다른 메서드로 인식

### 함수와 메서드의 차이는 무엇인가요?

- 함수는 이름이 있는 클로저, 클로저는 특정 작업을 수행하는 코드 묶음
- 메서드는 클래스, 구조체, 열거형 속에 포함되어 있는 함수

### 인스턴스 메서드에서는 일반 프로퍼티, 타입 프로퍼티 모두 사용할 수 있나요?

- 모두 사용 가능
- 인스턴스와 상관 없는 타입 멤버(프로퍼티&메서드)에 접근 시, 기존 방식과 같이 타입 이름을 통해서 접근

### 타입 메서드는 일반 프로퍼티, 타입 프로퍼티 모두 사용할 수 있나요?

- 타입 메서드에서는 타입 멤버(프로퍼티&메서드)만 사용 가능하고, 같은 타입 멤버는 타입 이름 없이 접근 가능

### 열거형에 인스턴스 / 타입 메서드를 생성할 수 있나요?

- 인스턴스 / 타입 메서드 모두 가능.
- 클래스 / 구조체 / 열거형 모두 가능하다는 것이 Swift의 특이한 점.

### 타입 메서드를 사용해본 경험이 있나요?

- JSONParser 사용할 때
- 열거형으로 네임스페이스를 사용할 때

### final 키워드는 무엇인가요?

- final 키워드를 통해 더 이상 상속이 필요없음을 명시할 수 있고, 오버라이드 할 시 컴파일 에러를 발생시킬 수 있다.
- 런타임 성능이 향상된다는 장점이 있다.

### final의 성능상 이점은 무엇인가요?

- 인스턴스의 메서드를 호출할 때 해당 클래스를 참조할지, 오버라이딩한 하위 클래스에서 참조해야 할지를 런타임 시점(Dynamic Dispatch)에 vTable이란 것을 통해 찾기 때문에 오버헤드가 발생
- final을 통해서 오버라이딩을 할 수 없으므로 해당 클래스를 참조할 것을 명시함으로서 런타임 시점에서 어떤 메서드인지 찾는 과정이 없으므로 비교적 성능이 좋다.

### vTable이 무엇인가요?

- Swift는 클래스마다 vTable을 가지고 있다.
- 메서드 오버라이딩에 따라 실행 시점에 어떤 메서드를 실행할지 결정하는 함수 포인트 들의 배열
- 함수가 호출되면 vTable에서 지금 class가 어떠한 함수를 호출해야 하는지 조회를 하고 해당 함수를 호출하는 방식

### Dynamic Dispatch

- 유동적으로 어떤 메소드와 프로퍼티를 호출할지 결정하는 방법
- 런타임에 결정
- Swift에서는 클래스마다 함수 포인터들의 배열인 vTable을 가지고 있다.
- 하위 클래스가 메서드를 호출할 때, 이 vTable을 참조하여 실제 호출할 함수를 결정한다.
- 이 과정들이 런타임에 일어나기 때문에 성능상 손해를 보게 된다.

### Static Dispatch

- 컴파일 타임에 이미 어떠한 메소드와 프로퍼티를 호출할지 결정
- Dynamic Dispatch처럼 결정하는 과정이 없으니 성능상으로 이점

### struct, mutating

1. 기본적으로 값 타입 (구조체, 열거형)은 인스턴스 메서드를 통해 프로퍼티의 값을 변경할 수 없다.
하지만 메서드에서 저장 프로퍼티 값을 바꾸고 싶다면? 해당 프로퍼티는 var로 선언하고, 해당 구조체 인스턴스는 변수에 할당해야 한다.
- 프로퍼티를 let으로 할당하면, 상수이므로 값을 바꿀 수 없다.
- 인스턴스를 let으로 할당하면, “불변 인스턴스”이므로 프로퍼티가 변수이더라도 값을 변경할 수 없다.

```swift
// 가변 인스턴스 생성
var mutable: Sample = Sample() // Sample 타입의 가변 인스턴스 생성 (var)
mutable.mutableProperty = 200 // 가변 인스턴스 프로퍼티이므로 수정 가능
//mutable.immutableProperty = 200 // 불변 인스턴스 프로퍼티는 수정 불가하므로 컴파일 오류
// 불변 인스턴스 생성
let immutable: Sample = Sample() // Sample 타입의 불변 인스턴스 생성 (let)
//immutable.mutableProperty = 200 // 불변 인스턴스는 아무리 가변 프로퍼티라도 수정 불가하므로 컴파일 오류
//immutable.immutableProperty = 200
```