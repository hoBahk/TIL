# Iterator Pattern

- Iterator Pattern은 list, stack, tree 등과 같은 기본적인 표현을 노출하지 않고 객체를 순차적으로 접근할 수 있는 방법을 제공하는 패턴


## 구조
- Iterator Interface:  컬렉션의 순회에 필요한 작업들​(예: 다음 요소 가져오기, 현재 위치 가져오기, 반복자 다시 시작 등)​을 선언
- ConcreteIterator: 컬렉션 순회를 위한 특정 알고리즘들을 구현합니다. 반복자 객체는 순회의 진행 상황을 자체적으로 추적해야 합니다. 이는 여러 반복자들이 같은 컬렉션을 서로 독립적으로 순회
- Collection Interface: 컬렉션과 호환되는 반복자들을 가져오기 위한 하나 이상의 메서드들을 선언합니다. 참고로 메서드들의 반환 유형은 반복자 인터페이스의 유형으로 선언되어야 합니다. 그래야 구상 컬렉션들이 다양한 유형의 반복자들을 반환할 수 있기 때문
- Concrete Collection: 클라이언트가 요청할 때마다 특정 구상 반복자 클래스의 새 인스턴스들을 반환

## 적용
- 컬렉션이 내부에 복잡한 데이터 구조가 있지만 이 구조의 복잡성을 보안이나 편의상의 이유로 클라이언트들로부터 숨기고 싶을 때 사용
- 앱 전체에서 순회 코드의 중복을 줄이고 싶을 때
- 코드가 다른 데이터 구조들을순회할 수 있기를 원할 떄 또는 이런한 구조들의 유형을 미리 알 수 없을 때 사용


## 장단점

### 장점
- 단일 책임 원칙, 부피가 큰 순회 알고리즘들을 별도의 클래스들로 추출하여 클라이언트 코드와 컬렉션들을 정돈할 수 있다.
- 개방/폐쇄 원칙. 새로운 유형의 컬렉션들과 반복자들을 구현할 수 있으며 이들을 아무것도 훼손하지 않을 채 기존의 코드에 전달할 수 있다.
- 같은 컬렉션을 병렬로 순회할 수 있다. 각 반복자 객체에는 자신의 고유한 순회 상태가 포함되어 있기 떄문
- 그렇기 때문에 순회를 지연하고 필요할 떄 계속 사용할 수 있다.


### 단점
- 단순한 컬렉션들과만 작동하는 경우 반복자 패턴을 적용하는것은 과도할수 있다.
- 반복자를 사용하는 것은 일부 특수 컬렉션들의 요소들을 직접 탐색하는 것 보다 효율이 떨어질 수 있다. 